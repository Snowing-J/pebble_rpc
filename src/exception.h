/**
 * Autogenerated by Pebble Compiler (1.0.0.652 11:33:50 Sep 20 2017)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 * Copyright (c) 2015, Tencent Inc. All rights reserved.
 */
#ifndef __exception_h__
#define __exception_h__

#include <iosfwd>

#include "dr/common/common.h"
#include "dr/protocol/protocol.h"




namespace pebble {

class Exception;

typedef struct _Exception__isset {
    _Exception__isset() : message(false), type(false) {}
    bool message :1;
    bool type :1;
} _Exception__isset;

class Exception {
public:
    static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
    static const uint8_t binary_fingerprint[16]; // = {0xEE, 0xBC, 0x91, 0x5C, 0xE4, 0x49, 0x01, 0x40, 0x1D, 0x88, 0x1E, 0x60, 0x91, 0x42, 0x30, 0x36};

    Exception(const Exception&);
    Exception& operator=(const Exception&);
    Exception() : message(), type(0) {
    }

    virtual ~Exception() throw();
    std::string message;
    int32_t type;

    _Exception__isset __isset;

    void __set_message(const std::string& val);

    void __set_type(const int32_t val);

    bool operator == (const Exception & rhs) const
    {
        if (!(message == rhs.message))
            return false;
        if (!(type == rhs.type))
            return false;
        return true;
    }
    bool operator != (const Exception &rhs) const {
        return !(*this == rhs);
    }

    // This must be implemented by the developer if they wish to use it.
    bool operator < (const Exception &) const;

    uint32_t read(::pebble::dr::protocol::TProtocol* iprot);
    uint32_t write(::pebble::dr::protocol::TProtocol* oprot) const;

    friend std::ostream& operator<<(std::ostream& out, const Exception& obj);
};

void swap(Exception &a, Exception &b);

} // namespace pebble

#endif // __exception_h__
